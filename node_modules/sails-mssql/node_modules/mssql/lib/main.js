// Generated by CoffeeScript 1.6.3
(function() {
  var Connection, DRIVERS, Request, TYPES, Transaction, events, getTypeByValue, global_connection, key, map, util, value,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  events = require('events');

  util = require('util');

  TYPES = require('./datatypes').TYPES;

  DRIVERS = ['msnodesql', 'tedious', 'tds'];

  global_connection = null;

  map = [];

  /*
  Register you own type map.
  
  **Example:**
  ```
  sql.map.register(MyClass, sql.Text);
  ```
  You can also overwrite default type map.
  ```
  sql.map.register(Number, sql.BigInt);
  ```
  
  @path module.exports.map
  @param {*} jstype JS data type.
  @param {*} sqltype SQL data type.
  */


  map.register = function(jstype, sqltype) {
    var index, item, _i, _len;
    for (index = _i = 0, _len = this.length; _i < _len; index = ++_i) {
      item = this[index];
      if (!(item.js === jstype)) {
        continue;
      }
      this.splice(index, 1);
      break;
    }
    this.push({
      js: jstype,
      sql: sqltype
    });
    return null;
  };

  map.register(String, TYPES.VarChar);

  map.register(Number, TYPES.Int);

  map.register(Boolean, TYPES.Bit);

  map.register(Date, TYPES.DateTime);

  /*
  @ignore
  */


  getTypeByValue = function(value) {
    var item, _i, _j, _k, _l, _len, _len1, _len2, _len3;
    if (value === null || value === void 0) {
      return TYPES.VarChar;
    }
    switch (typeof value) {
      case 'string':
        for (_i = 0, _len = map.length; _i < _len; _i++) {
          item = map[_i];
          if (item.js === String) {
            return item.sql;
          }
        }
        return TYPES.VarChar;
      case 'number':
        for (_j = 0, _len1 = map.length; _j < _len1; _j++) {
          item = map[_j];
          if (item.js === Number) {
            return item.sql;
          }
        }
        return TYPES.Int;
      case 'boolean':
        for (_k = 0, _len2 = map.length; _k < _len2; _k++) {
          item = map[_k];
          if (item.js === Boolean) {
            return item.sql;
          }
        }
        return TYPES.Bit;
      case 'object':
        for (_l = 0, _len3 = map.length; _l < _len3; _l++) {
          item = map[_l];
          if (value instanceof item.js) {
            return item.sql;
          }
        }
        return TYPES.VarChar;
      default:
        return TYPES.VarChar;
    }
  };

  /*
  Class Connection.
  
  @property {Boolean} connected If true, connection is established.
  @property {Boolean} connecting If true, connection is being established.
  @property {*} driver Reference to configured Driver.
  */


  Connection = (function() {
    Connection.prototype.connected = false;

    Connection.prototype.connecting = false;

    Connection.prototype.driver = null;

    /*
    	Create new Connection.
    	
    	@param {Object} config Connection configuration.
    	@callback callback A callback which is called after connection has established, or an error has occurred.
    		@param {Error} err Error on error, otherwise null.
    */


    function Connection(config, callback) {
      var err, _base, _base1, _ref;
      this.config = config;
      if ((_base = this.config).driver == null) {
        _base.driver = 'tedious';
      }
      if ((_base1 = this.config).port == null) {
        _base1.port = 1433;
      }
      if (_ref = this.config.driver, __indexOf.call(DRIVERS, _ref) >= 0) {
        this.driver = this.initializeDriver(require("./" + this.config.driver));
      } else {
        err = new Error("Unknown driver " + this.config.driver + "!");
        if (callback) {
          callback(err);
        } else {
          throw err;
        }
      }
      if (callback) {
        this.connect(callback);
      }
    }

    /*
    	Initializes driver for this connection. Separated from constructor and used by co-mssql.
    	
    	@private
    	@param {Function} driver Loaded driver.
    	
    	@returns {Connection}
    */


    Connection.prototype.initializeDriver = function(driver) {
      return driver(Connection, Transaction, Request);
    };

    /*
    	Create connection to the server.
    	
    	@callback callback A callback which is called after connection has established, or an error has occurred.
    		@param {Error} err Error on error, otherwise null.
    	
    	@returns {Connection}
    */


    Connection.prototype.connect = function(callback) {
      var err,
        _this = this;
      if (this.connected) {
        err = new Error("Database is already connected! Call close before connecting to different database.");
        if (callback) {
          callback(err);
        } else {
          throw err;
        }
      }
      if (this.connecting) {
        err = new Error("Already connecting to database! Call close before connecting to different database.");
        if (callback) {
          callback(err);
        } else {
          throw err;
        }
      }
      this.connecting = true;
      this.driver.Connection.prototype.connect.call(this, this.config, function(err) {
        if (!_this.connecting) {
          return;
        }
        _this.connecting = false;
        if (!err) {
          _this.connected = true;
        }
        return typeof callback === "function" ? callback(err) : void 0;
      });
      return this;
    };

    /*
    	Close connection to the server.
    	
    	@returns {Connection}
    */


    Connection.prototype.close = function() {
      if (this.connecting) {
        this.connecting = false;
        this.driver.Connection.prototype.close.call(this);
        this.driver = null;
      } else if (this.connected) {
        this.connected = false;
        this.driver.Connection.prototype.close.call(this);
        this.driver = null;
      }
      return this;
    };

    /*
    	Returns new request using this connection.
    	
    	@returns {Request}
    */


    Connection.prototype.request = function() {
      return new Request(this);
    };

    /*
    	Returns new transaction using this connection.
    	
    	@returns {Transaction}
    */


    Connection.prototype.transaction = function() {
      return new Transaction(this);
    };

    return Connection;

  })();

  /*
  Class Transaction.
  
  @property {Connection} connection Reference to used connection.
  */


  Transaction = (function() {
    Transaction.prototype._pooledConnection = null;

    Transaction.prototype._queue = null;

    Transaction.prototype._working = false;

    /*
    	Create new Transaction.
    	
    	@param {Connection} connection If ommited, global connection is used instead.
    */


    function Transaction(connection) {
      this.connection = connection != null ? connection : global_connection;
      this._queue = [];
    }

    /*
    	Begin a transaction.
    	
    	@callback callback A callback which is called after transaction has began, or an error has occurred.
    		@param {Error} err Error on error, otherwise null.
    	@returns {Transaction}
    */


    Transaction.prototype.begin = function(callback) {
      if (this._pooledConnection) {
        callback(new Error("Transaction is already running."));
        return this;
      }
      this.connection.driver.Transaction.prototype.begin.call(this, callback);
      return this;
    };

    /*
    	Commit a transaction.
    	
    	@callback callback A callback which is called after transaction has commited, or an error has occurred.
    		@param {Error} err Error on error, otherwise null.
    	@returns {Transaction}
    */


    Transaction.prototype.commit = function(callback) {
      if (!this._pooledConnection) {
        callback(new Error("Transaction has not started. Call begin() first."));
        return this;
      }
      this.connection.driver.Transaction.prototype.commit.call(this, callback);
      return this;
    };

    /*
    	Execute next request in queue.
    	
    	@private
    	@returns {Transaction}
    */


    Transaction.prototype.next = function() {
      if (this._queue.length) {
        return this._queue.shift()(null, this._pooledConnection);
      } else {
        return this._working = false;
      }
    };

    /*
    	Add request to queue for connection. If queue is empty, execute the request immediately.
    	
    	@private
    	@callback callback A callback to call when connection in ready to execute request.
    		@param {Error} err Error on error, otherwise null.
    		@param {*} conn Internal driver's connection.
    	@returns {Transaction}
    */


    Transaction.prototype.queue = function(callback) {
      if (!this._pooledConnection) {
        callback(new Error("Transaction has not started. Call begin() first."));
        return this;
      }
      if (this._working) {
        return this._queue.push(callback);
      } else {
        this._working = true;
        return callback(null, this._pooledConnection);
      }
    };

    /*
    	Returns new request using this transaction.
    	
    	@returns {Request}
    */


    Transaction.prototype.request = function() {
      return new Request(this);
    };

    /*
    	Rollback a transaction.
    	
    	@callback callback A callback which is called after transaction has rolled back, or an error has occurred.
    		@param {Error} err Error on error, otherwise null.
    	@returns {Transaction}
    */


    Transaction.prototype.rollback = function(callback) {
      if (!this._pooledConnection) {
        callback(new Error("Transaction has not started. Call begin() first."));
        return this;
      }
      this.connection.driver.Transaction.prototype.rollback.call(this, callback);
      return this;
    };

    return Transaction;

  })();

  /*
  Class Request.
  
  @property {Connection} connection Reference to used connection.
  @property {Transaction} transaction Reference to transaction when request was created in transaction.
  @property {*} parameters Collection of input and output parameters.
  @property {Boolean} verbose If `true`, debug messages are printed to message log.
  @property {Boolean} multiple If `true`, `query` will handle multiple recordsets (`execute` always expect multiple recordsets).
  */


  Request = (function() {
    Request.prototype.connection = null;

    Request.prototype.transaction = null;

    Request.prototype.parameters = null;

    Request.prototype.verbose = false;

    Request.prototype.multiple = false;

    /*
    	Create new Request.
    	
    	@param {Connection|Transaction} connection If ommited, global connection is used instead.
    */


    function Request(connection) {
      if (connection instanceof Transaction) {
        this.transaction = connection;
        this.connection = connection.connection;
      } else if (connection instanceof Connection) {
        this.connection = connection;
      } else {
        this.connection = global_connection;
      }
      this.parameters = {};
    }

    /*
    	Acquire connection for this request from connection.
    */


    Request.prototype._acquire = function(callback) {
      return this.connection.driver.Request.prototype._acquire.call(this, callback);
    };

    /*
    	Release connection used by this request.
    */


    Request.prototype._release = function(connection) {
      return this.connection.driver.Request.prototype._release.call(this, connection);
    };

    /*
    	Add an input parameter to the request.
    	
    	**Example:**
    	```
    	request.input('input_parameter', value);
    	request.input('input_parameter', sql.Int, value);
    	```
    	
    	@param {String} name Name of the input parameter without @ char.
    	@param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
    	@param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
    	@returns {Request}
    */


    Request.prototype.input = function(name, type, value) {
      if (arguments.length === 1) {
        throw new Error("Invalid number of arguments. At least 2 arguments expected.");
      } else if (arguments.length === 2) {
        value = type;
        type = getTypeByValue(value);
      }
      if ((value != null ? value.valueOf : void 0) && !(value instanceof Date)) {
        value = value.valueOf();
      }
      if (value === void 0) {
        value = null;
      }
      if (value !== value) {
        value = null;
      }
      this.parameters[name] = {
        name: name,
        type: type,
        io: 1,
        value: value
      };
      return this;
    };

    /*
    	Add an output parameter to the request.
    	
    	**Example:**
    	```
    	request.output('output_parameter', sql.Int);
    	```
    	
    	@param {String} name Name of the output parameter without @ char.
    	@param {*} type SQL data type of output parameter.
    	@returns {Request}
    */


    Request.prototype.output = function(name, type) {
      if (!type) {
        type = tds.TYPES.VarChar;
      }
      this.parameters[name] = {
        name: name,
        type: type,
        io: 2
      };
      return this;
    };

    /*
    	Execute the SQL command.
    	
    	**Example:**
    	```
    	var request = new sql.Request();
    	request.query('select 1 as number', function(err, recordset) {
    	    console.log(recordset[0].number); // return 1
    	
    	    // ...
    	});
    	```
    	
    	You can enable multiple recordsets in querries by `request.multiple = true` command.
    	
    	```
    	var request = new sql.Request();
    	request.multiple = true;
    	
    	request.query('select 1 as number; select 2 as number', function(err, recordsets) {
    	    console.log(recordsets[0][0].number); // return 1
    	    console.log(recordsets[1][0].number); // return 2
    	
    	    // ...
    	});
    	```
    	
    	@param {String} command T-SQL command to be executed.
    	@callback callback A callback which is called after execution has completed, or an error has occurred.
    		@param {Error} err Error on error, otherwise null.
    		@param {*} recordset Recordset.
    	
    	@returns {Request}
    */


    Request.prototype.query = function(command, callback) {
      if (!this.connection) {
        return process.nextTick(function() {
          return typeof callback === "function" ? callback(new Error("No connection is specified for that request.")) : void 0;
        });
      }
      this.connection.driver.Request.prototype.query.call(this, command, callback);
      return this;
    };

    /*
    	Call a stored procedure.
    	
    	**Example:**
    	```
    	var request = new sql.Request();
    	request.input('input_parameter', sql.Int, value);
    	request.output('output_parameter', sql.Int);
    	request.execute('procedure_name', function(err, recordsets, returnValue) {
    	    console.log(recordsets.length); // count of recordsets returned by procedure
    	    console.log(recordset[0].length); // count of rows contained in first recordset
    	    console.log(returnValue); // procedure return value
    	
    	    console.log(request.parameters.output_parameter.value); // output value
    	
    	    // ...
    	});
    	```
    	
    	@param {String} procedure Name of the stored procedure to be executed.
    	@callback callback A callback which is called after execution has completed, or an error has occurred.
    		@param {Error} err Error on error, otherwise null.
    		@param {*} recordset Recordset.
    		@param {Number} returnValue Procedure return value.
    	
    	@returns {Request}
    */


    Request.prototype.execute = function(procedure, callback) {
      if (!this.connection) {
        return process.nextTick(function() {
          return typeof callback === "function" ? callback(new Error("No connection is specified for that request.")) : void 0;
        });
      }
      this.connection.driver.Request.prototype.execute.call(this, procedure, callback);
      return this;
    };

    /*
    	Cancel currently executed request.
    	
    	@returns {Request}
    */


    Request.prototype.cancel = function() {
      this.connection.driver.Request.prototype.cancel.call(this);
      return this;
    };

    return Request;

  })();

  /*
  Open global connection.
  
  @param {Object} config Connection configuration.
  @callback callback A callback which is called after connection has established, or an error has occurred.
  	@param {Error} err Error on error, otherwise null.
  	
  @returns {Connection}
  */


  module.exports.connect = function(config, callback) {
    global_connection = new Connection(config);
    return global_connection.connect(callback);
  };

  /*
  Close global connection.
  	
  @returns {Connection}
  */


  module.exports.close = function() {
    return global_connection != null ? global_connection.close() : void 0;
  };

  module.exports.Connection = Connection;

  module.exports.Transaction = Transaction;

  module.exports.Request = Request;

  module.exports.DRIVERS = DRIVERS;

  module.exports.TYPES = TYPES;

  module.exports.map = map;

  for (key in TYPES) {
    value = TYPES[key];
    module.exports[key] = value;
    module.exports[key.toUpperCase()] = value;
  }

  module.exports.pool = {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  };

  module.exports.connection = {
    userName: '',
    password: '',
    server: ''
  };

  /*
  Initialize Tedious connection pool.
  
  @deprecated
  */


  module.exports.init = function() {
    return module.exports.connect({
      user: module.exports.connection.userName,
      password: module.exports.connection.password,
      server: module.exports.connection.server,
      options: module.exports.connection.options,
      driver: 'tedious',
      pool: module.exports.pool
    });
  };

}).call(this);
